package image;

import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.WindowManager;
import ij.gui.HistogramWindow;
import ij.gui.Plot;
import ij.process.ByteProcessor;
import ij.process.ColorProcessor;
import ij.process.ImageProcessor;
import ij.process.ImageConverter;

import java.awt.Image;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.RenderedImage;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Vector;

import javax.media.jai.JAI;
import javax.media.jai.KernelJAI;
import javax.media.jai.RenderedOp;
import javax.media.jai.operator.ErodeDescriptor;
import javax.swing.text.MaskFormatter;

import org.ietf.jgss.Oid;

import Watershed.WatershedPixel;

import net.sf.ij_plugins.color.ColorSpaceConvertion;

public class ImageOperations {
	
	public  static ByteProcessor 			   AND(ImageProcessor image1, ImageProcessor image2) {
		int width1 = image1.getWidth();
		int height1 = image1.getHeight();
		int width2 = image2.getWidth();
		int height2 = image2.getHeight();
		ByteProcessor imagesAND = null;
		int pixel1, pixel2;
		
		try {
			if(width1==width2 && height1==height2) {
				
				imagesAND = new ByteProcessor(width1,height1);
				for(int y = 0; y < height1; y++) {
					for(int x = 0; x < width1; x++) {
						pixel1 = image1.getPixel(x, y);
						pixel2 = image2.getPixel(x, y);
						if(pixel1==0 || pixel2==0) {
							imagesAND.set(x, y, 0);
						} else
							imagesAND.set(x, y, pixel1);
					}
				}
				return imagesAND;
			} else 
				throw new Exception();
		} catch (Exception e) {
			System.out.println("Images are not of the same size.");
		}
		return imagesAND;
	}

	public  static int 						   computeCutOffFrequency(ImageProcessor fftIm) {
		//int cutoffFreq = 110;
		//double[] fftProfile = fftIm.getLine(0, 0, fftIm.getWidth()-1, fftIm.getHeight()-1);
		double[] fftProfile = fftIm.getLine(fftIm.getWidth()/2, fftIm.getHeight()/2, fftIm.getWidth()-1, fftIm.getHeight()/2);
		double[] xValues = new double[fftProfile.length];
		double avF = 0, sdF = 0; //average frequency, standard deviation
		int cutoffFreq = 0;
		   
		for(int i = 0; i < xValues.length; i++)
		  	xValues[i] = i;
		Plot fftProfilePlot = new Plot("FFT Profile", "", "Magnitude", xValues, fftProfile);
		fftProfilePlot.show();
		    
		/*for(int i = 0; i < fftProfile.length; i++) 
			avF += fftProfile[i];
		avF = avF/fftProfile.length;
		
		for(int i = 0; i < fftProfile.length; i++) 
			sdF += Math.pow(fftProfile[i] - avF, 2);
		sdF = Math.sqrt(sdF/fftProfile.length);*/	
		double lim = fftProfile[0]*0.4;
		for(int i = 1; i < fftProfile.length; i++) { 
		   	if(fftProfile[i] <= lim/*avF + sdF*/) {
		   		//cutoffFreq = fftProfile.length/2-(i-1);
		   		cutoffFreq = i;
		   		break;
		   	}
		}
		//cutoffFreq = (int) avF + 2 * (int)sdF;
		return cutoffFreq;
	}

	public  static ByteProcessor[]  		   convertfromRGBtoHSB(BufferedImage image) {
		ImagePlus imagePlus = new ImagePlus("", image);
		ImageProcessor imageP;
		ImageStack imageStack;
	    ByteProcessor[] imageHSB = new ByteProcessor[3];
	    
		new ImageConverter(imagePlus).convertToHSB();
		imageStack = imagePlus.getStack();
		
		//imageHSB = (ByteProcessor[]) imageStack.getImageArray();
		
		imageP = imageStack.getProcessor(1);
		imageHSB[0] = new ByteProcessor(imageP.getWidth(), imageP.getHeight(), (byte[]) imageP.getPixels(), imageP.getColorModel());
		imageP = imageStack.getProcessor(2);
		imageHSB[1] = new ByteProcessor(imageP.getWidth(), imageP.getHeight(), (byte[]) imageP.getPixels(), imageP.getColorModel());
		imageP = imageStack.getProcessor(3);
		imageHSB[2] = new ByteProcessor(imageP.getWidth(), imageP.getHeight(), (byte[]) imageP.getPixels(), imageP.getColorModel());
		
		return imageHSB;
	}
	
	public  static ByteProcessor[]  		   convertfromRGBtoYCbCr(BufferedImage rgb) {
		ColorProcessor rgpCP = new ColorProcessor(rgb);
		return ColorSpaceConvertion.rgbToYCbCr(rgpCP);
	}
	
	public  static ImageProcessor   		   copyImage(ImageProcessor image) {
		ImageProcessor image_copy = image.createProcessor(image.getWidth(), image.getHeight());
		image_copy.setPixels(image.getPixelsCopy());
		return image_copy;
	} 

	public  static int 		 	    		   countRBC(ImageProcessor watershedIm) {
		int w = watershedIm.getWidth();
		int h = watershedIm.getHeight();
		ImageProcessor imageproc = ImageOperations.copyImage(watershedIm);
		ArrayList<ArrayList<Pixel>> connectedComps;
		ArrayList<Pixel> connectedComp;
		Pixel curPixel;
		int x,y;
		
		connectedComps = findConnectedComponents(imageproc);
		
		//*********************
		//remove cells that are not completely included on the image
		
		for(int k=0; k < connectedComps.size(); k++) {
			connectedComp = connectedComps.get(k);
			for(int i=0; i <  connectedComp.size(); i++) {
				curPixel = connectedComp.get(i);
				x = curPixel.getX(); y = curPixel.getY();
				if(x==0 || x==w-1 || y==0 || y==h-1) {
					connectedComps.set(k, null);
					break;
				}
			}
		}
		
		showConnectedComponents(connectedComps, w, h);
		//*********************
		
		return 0;
	}
	
	public  static int						   countRBC(ImageProcessor im, int diameter) {
		ImagePlus imagep = new ImagePlus();
		//double diameter = 31;
		int w = im.getWidth();
		int h= im.getHeight();
		int offset, bottomOffset, topOffset, i, label=0;
		byte[] pixelsSrc = (byte[]) im.getPixels(); 
		byte[] pixels = new byte[pixelsSrc.length];
		System.arraycopy(pixelsSrc, 0, pixels, 0, pixelsSrc.length);
		ColorModel colorModel = new ComponentColorModel(
				ColorSpace.getInstance(ColorSpace.CS_GRAY), false, false, 1, 0);
		ByteProcessor image = new ByteProcessor(w, h, pixels, colorModel);
		ArrayList<Pixel> pixelArray = new ArrayList<Pixel>();
		ArrayList<Pixel> referencePixels = new ArrayList<Pixel>();
		referencePixels.add(new Pixel());
		
		ByteProcessor outputIm = new ByteProcessor(w, h);
		ImagePlus outputImPlus = new ImagePlus("Labeling", outputIm);
		
		//*********************
		//remove cells that are not completely included on the image
		imagep.setProcessor(image);
		for(int x = 0; x < w; x++) {
			Pixel pixel = new Pixel(x, 0, (byte) image.getPixel(x, 0));
			if(pixel.getIntHeight()==255) {
				System.out.println("\nBegin");
				removeNeighbours(pixel,image,pixel,diameter);
				//outputImPlus.show();
			}
		}
		
		for(int x = 0; x < w; x++) {
			Pixel pixel = new Pixel(x, h-1, (byte) image.getPixel(x, h-1));
			if(pixel.getIntHeight()==255) {
				System.out.println("\nBegin");
				removeNeighbours(pixel,image,pixel,diameter);
				//outputImPlus.show();
			}
		}
		
		for(int y = 1; y < h-1; y++) {
			Pixel pixel = new Pixel(0, y, (byte) image.getPixel(0, y));
			if(pixel.getIntHeight()==255) {
				System.out.println("\nBegin");
				removeNeighbours(pixel,image,pixel,diameter);
				//outputImPlus.show();
			}
		}
		
		for(int y = 1; y < h-1; y++) {
			Pixel pixel = new Pixel(w-1, y, (byte) image.getPixel(w-1, y));
			if(pixel.getIntHeight()==255) {
				System.out.println("\nBegin");
				removeNeighbours(pixel,image,pixel,diameter);
				//outputImPlus.show();
			}
		}
		//*********************
		
		for (int y = 0; y < h; y++) {
			offset = y * w;

			System.out.println("Progress: "+(0.1 + 0.3 * y / h));

			for (int x = 0; x < w; x++) {
				i = offset + x;
				pixelArray.add(new Pixel(x, y, pixels[i]));
			}
		}
		
		//add neighbors
		
		for (int y = 0; y < h; y++) {
			offset = y * w;
			topOffset = offset + w;
			bottomOffset = offset - w;

			//ByteProcessor outputIm = new ByteProcessor(w, h);
			
			System.out.println("Progress: "+(0.1 + 0.3 * y / h));
			
			for (int x = 0; x < w; x++) {
				Pixel currentPixel = pixelArray.get(x + offset);
				//outputIm.putPixel(currentPixel.getX(), currentPixel.getY(), 255);
				Pixel neighbour = new Pixel();
				
				if (x - 1 >= 0) {
					neighbour = pixelArray.get(x - 1 + offset);
					currentPixel.addNeighbour(neighbour);
					//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);

					if (y - 1 >= 0) {
						neighbour = pixelArray.get(x - 1 + bottomOffset);
						currentPixel.addNeighbour(neighbour);
						//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
					
					if (y + 1 < h) {
						neighbour = pixelArray.get(x - 1 + topOffset);
						currentPixel.addNeighbour(neighbour);
						//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
				}
				/*if (x - 2 >= 0) {
					neighbour = pixelArray.get(x - 2 + offset);
					currentPixel.addNeighbour(neighbour);
				//	outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					
					if (y - 1 >= 0) {
						neighbour = pixelArray.get(x - 2 + bottomOffset);
						currentPixel.addNeighbour(neighbour);
					//	outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
				}
				if (x - 3 >= 0) {
					neighbour = pixelArray.get(x - 3 + offset);
					currentPixel.addNeighbour(neighbour);
				//	outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					
					if (y - 1 >= 0) {
						neighbour = pixelArray.get(x - 3 + bottomOffset);
						currentPixel.addNeighbour(neighbour);
					//	outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
				}
				if (x - 4 >= 0) {
					neighbour = pixelArray.get(x - 4 + offset);
					currentPixel.addNeighbour(neighbour);
//					outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					
					if (y - 1 >= 0) {
						neighbour = pixelArray.get(x - 4 + bottomOffset);
						currentPixel.addNeighbour(neighbour);
					//	outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
				}*/
				if (x + 1 < w) {
					neighbour = pixelArray.get(x + 1 + offset);
					currentPixel.addNeighbour(neighbour);
					//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					
					if (y - 1 >= 0) {
						neighbour = pixelArray.get(x + 1 + bottomOffset);
						currentPixel.addNeighbour(neighbour);
						//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
					
					if (y + 1 < h) {
						neighbour = pixelArray.get(x + 1 + topOffset);
						currentPixel.addNeighbour(neighbour);
						//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
				}
				/*if(x + 2 < w) {
					if (y - 1 >= 0) {
						neighbour = pixelArray.get(x + 2 + bottomOffset);
						currentPixel.addNeighbour(neighbour);
						//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
				}
				if(x + 3 < w) {
					if (y - 1 >= 0) {
						neighbour = pixelArray.get(x + 3 + bottomOffset);
						currentPixel.addNeighbour(neighbour);
						//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
				}
				if(x + 4 < w) {
					if (y - 1 >= 0) {
						neighbour = pixelArray.get(x + 4 + bottomOffset);
						currentPixel.addNeighbour(neighbour);
						//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
					}
				}*/
				if (y - 1 >= 0) {
					neighbour = pixelArray.get(x + bottomOffset);
					currentPixel.addNeighbour(neighbour);
					//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
				}
				
				if (y + 1 < h) {
					neighbour = pixelArray.get(x + topOffset);
					currentPixel.addNeighbour(neighbour);
					//outputIm.putPixel(neighbour.getX(), neighbour.getY(), 255);
				}
					
				//outputImPlus.setProcessor(outputIm);
				//outputImPlus.show();
			}
		}
		
		//*************************
		// Find red blood cells
		Vector<ArrayList<Pixel>> labeledPixelsSet = new Vector<ArrayList<Pixel>>(); 
		labeledPixelsSet.add(new ArrayList<Pixel>());
		
		for(int k = 0; k < pixelArray.size(); k++) {
			Pixel currentPixel = pixelArray.get(k);
			int x = currentPixel.getX();
			int y = currentPixel.getY();
			
			if((image.getPixel(x, y) & 0xff)==255) {
				label++;
				ArrayList<Pixel> labeledPixels = new ArrayList<Pixel>();
				labelRBC(currentPixel,labeledPixels,label);
				labeledPixelsSet.add(label, labeledPixels);
				
				//remove set from Image
				for(int n = 0; n < labeledPixels.size(); n++) {
					Pixel pixel = labeledPixels.get(n);
					image.putPixel(pixel.getX(), pixel.getY(), 0);
				}
			}
		}
		//************************
		
		//************************
		// Check for overlying RBC
		ArrayList<Pixel> labeledPixels, labeledPixels_aux;
		Pixel currentPixel;
		int passedNumberofSets = labeledPixelsSet.size();
		double distance;
		
		for(int k = 1; k < passedNumberofSets; k++) {
			labeledPixels = labeledPixelsSet.get(k);
			labeledPixels_aux = (ArrayList<Pixel>) labeledPixels.clone();
			ArrayList<Pixel> new_labeledPixels = new  ArrayList<Pixel>();
			Pixel reference = labeledPixels.get(0); 
			int count = 0;
			
			for(int n = 1; n < labeledPixels_aux.size(); n++) {
				currentPixel = labeledPixels_aux.get(n);
				distance = pixelsDistance(currentPixel, reference);
				outputIm.putPixel(currentPixel.getX(), currentPixel.getY(), (currentPixel.getLabel()*50)%256);
				outputImPlus.show();
				
				if(distance > diameter) {
					if(count==0)
						label++;
					labeledPixels.remove(currentPixel);
					currentPixel.setLabel(label);
					new_labeledPixels.add(currentPixel);
					count++;
					
					outputIm.putPixel(currentPixel.getX(), currentPixel.getY(), (currentPixel.getLabel()*50)%256);
					outputImPlus.show();
				}
			}
			
			if(count>0)
				labeledPixelsSet.add(label,new_labeledPixels);
		}
		
		//second check
		for(int k = passedNumberofSets; k < labeledPixelsSet.size(); k++) {
			labeledPixels = labeledPixelsSet.get(k);
			labeledPixels_aux = (ArrayList<Pixel>) labeledPixels.clone();
			ArrayList<Pixel> new_labeledPixels = new  ArrayList<Pixel>();
			Pixel reference = labeledPixels.get(0); 
			int count = 0;
			
			for(int n = 1; n < labeledPixels_aux.size(); n++) {
				currentPixel = labeledPixels_aux.get(n);
				distance = pixelsDistance(currentPixel, reference);
							
				if(distance > diameter) {
					if(count==0)
						label++;
					labeledPixels.remove(currentPixel);
					currentPixel.setLabel(label);
					new_labeledPixels.add(currentPixel);
					count++;
					
					outputIm.putPixel(currentPixel.getX(), currentPixel.getY(), (currentPixel.getLabel()*50)%256);
					outputImPlus.show();
				}
			}
			
			if(count>0)
				labeledPixelsSet.add(label,new_labeledPixels);
		}
		//*****************************
		
		/*for(int k = 0; k < pixelArray.size(); k++) {
			Pixel currentPixel = pixelArray.get(k);
			System.out.println(currentPixel.toString());
			if(currentPixel.getIntHeight()==255) {
				Vector arrayNeighbours = currentPixel.getNeighbours();
				Pixel referencePixel;
				int passedLabel = Pixel.INIT, neighbourLabel, count = 0;
				double distance, min_distance=200;
				
				for(int n = 0; n < arrayNeighbours.size(); n++) {
					Pixel neighbour = (Pixel) arrayNeighbours.get(n);
					neighbourLabel = neighbour.getLabel();					
					
					if(neighbourLabel!=Pixel.INIT) {
						if(neighbourLabel != passedLabel) {
							referencePixel = referencePixels.get(neighbourLabel);
							distance = pixelsDistance(currentPixel.getX(),currentPixel.getY(), referencePixel.getX(), referencePixel.getY());
							if(distance < min_distance) {
								min_distance = distance;
								currentPixel.setLabel(neighbourLabel);
								outputIm.putPixel(currentPixel.getX(), currentPixel.getY(), (currentPixel.getLabel()*50)%256);
								outputImPlus.show();
							}
						}
						passedLabel = neighbourLabel;
						count++;
					}
				}
				
				if(count==0 || min_distance>diameter) {
					label++;
					currentPixel.setLabel(label);
					referencePixels.add(label, currentPixel);
					
					outputIm.putPixel(currentPixel.getX(), currentPixel.getY(), (currentPixel.getLabel()*50)%256);
					outputImPlus.show();
				}
				System.out.println(currentPixel.toString());
			}
		}*/
		return label;
	}

	public  static ByteProcessor 			   distanceTransform(ImageProcessor imageproc) {
		ImageProcessor image = removeBorder(imageproc);
		new ImagePlus("",image).show();
		//System.out.println(image.getSliceNumber());
		//int pixel_in, pixel_out;
		int out,max_graylevel=0,min_graylevel=255,pixelValue;
		byte ws_d;
		//byte[] pixels_in = (byte[]) image.getPixels();
		int height = image.getHeight();
		int width  = image.getWidth();
		ByteProcessor distanceImage = new ByteProcessor(width, height);
		ImagePlus distImagePlus =  new ImagePlus("",distanceImage);
		distImagePlus.show();
		for (int yy=0; yy<height; yy++) {
			for(int xx=0; xx<width; xx++) {
				if(image.getPixel(xx,yy)==0) 
					distanceImage.putPixelValue(xx,yy,0);
			    else {
			        out = 0;
			        ws_d = 1;
			        while (out==0) {
			        	for(int y1=(yy-ws_d); y1<=(yy+ws_d); y1++) {
			        		for(int x1=(xx-ws_d); x1<=(xx+ws_d); x1++) {
			        			if( (y1>=0) && (x1>=0) && (y1<height) && (x1<width)) {
			        				if(image.getPixel(x1,y1)==0) {
			        					//new ImagePlus("",image).show();
			        					pixelValue = (255-ws_d)*(width/50) & 0xff;
			        					distanceImage.putPixel(xx,yy,pixelValue);
			        					out=1;
			        					if( (255-ws_d)>max_graylevel ) 
			        						max_graylevel = 255-ws_d;
			        					if( (255-ws_d)<min_graylevel )
			        						min_graylevel = 255-ws_d;
			                        }
			        				//distImagePlus.show();
			                    }
			                    if(out==1) break;
			                 }
	                         if(out==1) break;
		                 }
			             ws_d++;
			        }
			    }
			}
		}
		
		distanceImage.setMinAndMax(0, max_graylevel);
		return distanceImage;
		/*ImageProcessor G_ = image.createProcessor(width, height); //new ByteProcessor(width, height);
		ImageProcessor G  = image.createProcessor(width, height); //new ByteProcessor(width, height);
		//int[] pixels_out = (int[]) G_.getPixels();
		
		for(int i = 0; i < height; i++) {
			for(int j = 0; j < width; j++) {
				G_.putPixelValue(i, j, height*width);
				G.putPixelValue(i, j, height*width);
			}
		}
		
	// Algoritmo de Saito e Toriwaki
		
		// Transformacao 1 (linhas)
		// forward scan
		for(int i = 0; i<height; i++) {
			//pixel = pixels_in[i*width];
			pixel_in = image.getPixel(i, 0);
		    //if( pixel_in == 0) {
		    	//pixels_out[i*width] = 0;
		    	pixel_out = G_.getPixel(i, 0);
		    	pixel_out = 0;
		    	G_.putPixelValue(i, 0, 0);
		    //}
		    for (int j = 1; j<width; j++) {
		    	//pixel_in = pixels_in[i*width + j];
		    	pixel_in  = image.getPixel(i, j);
		    	pixel_out = G_.getPixel(i, j);
		        if(pixel_in != 0) {
		        	//pixels_out[i*width + j] = (G_.getPixel(i,j-1)^(1/2) + 1)^2;
		        	pixel_out = (G_.getPixel(i,j-1)^(1/2) + 1)^2;
		        	G_.putPixelValue(i, j, pixel_out);
		        } else {
		        	//pixels_out[i*width + j] = 0;
		        	//pixel_out = 0;
		        	G_.putPixelValue(i, 0, 0);
		        }
		    }
		}
		
		return G_;*/
		
	}
	
	public  static ImageProcessor              differenceImage(ImageProcessor im1, ImageProcessor im2) {
		int w1 = im1.getWidth(), h1 = im1.getHeight();
		int w2 = im1.getWidth(), h2 = im1.getHeight();
		ImageProcessor imDiff = im1.createProcessor(w1, h1);
		int pixelValue1, pixelValue2;
		
		if(w1!=w2 || h1!=h2)
			return null;
		else 
			for(int y=0; y<h1; y++)
				for(int x=0; x<w1; x++) {
					pixelValue1 = im1.getPixel(x, y);
					pixelValue2 = im2.getPixel(x, y);
					imDiff.putPixelValue(x, y, Math.abs(pixelValue1-pixelValue2) );
				} 
		
		return imDiff;
	}
	
	public  static ByteProcessor    		   doBinaryThresholding(ImageProcessor image, int threshold) {
		byte[] pixels = (byte[]) image.getPixels();
		int[] pixels_int = new int[pixels.length];
		byte[] pixels_out = pixels.clone();
		
		for(int i=0; i<pixels.length; i++)
			pixels_int[i] = Integer.parseInt(""+pixels[i]);
		
		for(int i=0; i<pixels.length; i++) {
			int value = pixels[i] & 0xff; 
			if(value < threshold)
				pixels_out[i] = 0;
			else
				pixels_out[i] = (byte) 255;
		}
		
		ColorModel colorModel = new ComponentColorModel(
				ColorSpace.getInstance(ColorSpace.CS_GRAY), false, false, 1, 0);
		
		return new ByteProcessor(image.getWidth(),image.getHeight(),pixels_out,colorModel);
	}

	public  static ByteProcessor   		  	   doOtsuThresholding(ImageProcessor image) {
		double[] hist_norm = normalizedHistogram(image);
		int L = (int) Math.pow(2,image.getColorModel().getComponentSize(0)); // number of gray levels
		double[] P = new double[L];
		double[] m = new double[L];
		double mG;                     //Average intensity of entire image
		double[] var = new double[L];   //between-class variance
		double max_var = 0;
		int optimum_k = 0;             //Otsu's threshold value              
		
		//new ImagePlus("crop", image).show();
		
		for(int k = 0; k < L; k++) {
			if(k==0) {
				P[k] = hist_norm[k];
				m[k] = k*hist_norm[k];
			} else {
				P[k] = P[k-1] + hist_norm[k];   //Probability of pixel with intensity <= k
				m[k] = m[k-1] + k*hist_norm[k]; //Average intensity up to level k
			}
			/*for(int i = 0; i <= k; i++) {
				P[k] = P[k] + hist_norm[i];    //Probability of pixel with intensity <= k
				m[k] = m[k] + i*hist_norm[i];  //Average intensity up to level k
			}*/
		}
		mG = m[L-1];
		
		//Compute between-class variance
		for(int k = 0; k < L; k++) {
			var[k] = Math.pow( mG * P[k] - m[k], 2 ) / ( P[k] * (1-P[k]) );
			if(var[k] > max_var) {
				max_var = var[k];
				optimum_k = k;
			}
		}
		
		return doBinaryThresholding(image, optimum_k);
	}
		
	public  static ImageProcessor 			   doOtsuThresholding(ImageProcessor image, int n) {
		int w = image.getWidth();
		int h = image.getHeight();
		int n_pix_X = w/n;
		int n_pix_Y = h/n;
		int xDif, yDif;
		ImageProcessor image_out = image.createProcessor(w, h);
		ImageProcessor image_crop = image.createProcessor(n_pix_X, n_pix_Y);
		ImageProcessor image_cropS = image.createProcessor(w, h);
		ImageProcessor otsuImage_crop = image.createProcessor(n_pix_X, n_pix_Y);
		ImagePlus im_outPlus = new ImagePlus("cropOtsu", image_out);
		ImagePlus im_cropPlus = new ImagePlus("crop", image_cropS);
		
		for(int i=0; i<=n; i++) {
			for(int j=0; j<=n; j++) {
				if( n_pix_X*(j+1) >= w && n_pix_Y*(i+1) >= h) {  // image block smaller than standard block in y and x
					xDif = n_pix_X*(j+1)-w;
					yDif = n_pix_Y*(i+1)-h;
					image_crop = image.createProcessor(n_pix_X-xDif, n_pix_Y-yDif);
				
					for(int y=0; y < image_crop.getHeight(); y++ ) {
						for(int x=0; x < image_crop.getWidth(); x++ ) {
							image_crop.putPixel(x, y, image.get(n_pix_X*j + x, n_pix_Y*i + y));
							image_cropS.putPixel(n_pix_X*j + x, n_pix_Y*i + y, image_crop.get( x, y));
						}
					}
					im_cropPlus.show();
					otsuImage_crop = doOtsuThresholding(image_crop);
					
					for(int y=0; y < image_crop.getHeight(); y++ ) {
						for(int x=0; x < image_crop.getWidth(); x++ ) {
							image_out.putPixel(n_pix_X*j + x, n_pix_Y*i + y, otsuImage_crop.get( x, y));
						}
					}
					im_outPlus.show();
				} else if(n_pix_X*(j+1) >= w) {                  // image block smaller than standard block in x
					xDif = n_pix_X*(j+1)-w;
					image_crop = image.createProcessor(n_pix_X-xDif, n_pix_Y);
					
					for(int y=0; y < image_crop.getHeight(); y++ ) {
						for(int x=0; x < image_crop.getWidth(); x++ ) {
							image_crop.putPixel(x, y, image.get(n_pix_X*j + x, n_pix_Y*i + y));
							image_cropS.putPixel(n_pix_X*j + x, n_pix_Y*i + y, image_crop.get( x, y));
						}
					}
					im_cropPlus.show();
					otsuImage_crop = doOtsuThresholding(image_crop);
				
					for(int y=0; y < image_crop.getHeight(); y++ ) {
						for(int x=0; x < image_crop.getWidth(); x++ ) 
							image_out.putPixel(n_pix_X*j + x, n_pix_Y*i + y, otsuImage_crop.get( x, y));
					}
					im_outPlus.show();
				} else if(n_pix_Y*(i+1) >= h) {                  // image block smaller than standard block in y
					yDif = n_pix_Y*(i+1)-h;
					image_crop = image.createProcessor(n_pix_X, n_pix_Y-yDif);
				
					for(int y=0; y < image_crop.getHeight(); y++ ) {
						for(int x=0; x < image_crop.getWidth(); x++ ) {
							image_crop.putPixel(x, y, image.get(n_pix_X*j + x, n_pix_Y*i + y));
							image_cropS.putPixel(n_pix_X*j + x, n_pix_Y*i + y, image_crop.get( x, y));
						}
					}
					im_cropPlus.show();
					otsuImage_crop = doOtsuThresholding(image_crop);
					
					for(int y=0; y < image_crop.getHeight(); y++ ) {
						for(int x=0; x < image_crop.getWidth(); x++ ) 
							image_out.putPixel(n_pix_X*j + x, n_pix_Y*i + y, otsuImage_crop.get( x, y));
					}
					im_outPlus.show();
				} else {
					image_crop = image.createProcessor(n_pix_X, n_pix_Y);
					
					for(int y=0; y < n_pix_Y; y++ ) {
						for(int x=0; x < n_pix_X; x++ ) {
							image_crop.putPixel(x, y, image.get(n_pix_X*j + x, n_pix_Y*i + y));
							image_cropS.putPixel(n_pix_X*j + x, n_pix_Y*i + y, image_crop.get( x, y));
						}
					}
					im_cropPlus.show();
					otsuImage_crop = doOtsuThresholding(image_crop);
				
					for(int y=0; y < n_pix_Y; y++ ) {
						for(int x=0; x < n_pix_X; x++ ) 
							image_out.putPixel(n_pix_X*j + x, n_pix_Y*i + y, otsuImage_crop.get( x, y));
					}
					im_outPlus.show();
				}
			}
		}
		
		return image_out;
	}
		
	public  static ByteProcessor    		   doThresholding(ImageProcessor image, int threshold) {
		byte[] pixels = (byte[]) image.getPixels();
		int[] pixels_int = new int[pixels.length];
		byte[] pixels_out = pixels.clone();
		
		for(int i=0; i<pixels.length; i++)
			pixels_int[i] = Integer.parseInt(""+pixels[i]);
		
		for(int i=0; i<pixels.length; i++) {
			int value = pixels[i] & 0xff; 
			if(value < threshold)
				pixels_out[i] = 0;
			else
				pixels_out[i] = pixels[i];
		}
		
		ColorModel colorModel = new ComponentColorModel(
				ColorSpace.getInstance(ColorSpace.CS_GRAY), false, false, 1, 0);
		
		return new ByteProcessor(image.getWidth(),image.getHeight(),pixels_out,colorModel);
	}

	public  static ArrayList<ArrayList<Pixel>> findConnectedComponents(ImageProcessor imageproc) {
		int w = imageproc.getWidth(), h = imageproc.getHeight();
		//byte pixelValue;
		Pixel currentPixel;
		int offset, curPixelValue, label = 0, count;
		int[] neighboursLabels = new int[4];
		int neigL, curL = 0;
		Matrix equivalenceMatrix = null; 
		ArrayList<Pixel> connectedComp;
		//ImageProcessor labelIm = imageproc.createProcessor(w, h);
		ArrayList<ArrayList<Pixel>> connectedComps = new ArrayList<ArrayList<Pixel>>();
		
		ArrayList<Pixel> imagePixels = imagePixels(imageproc);
		
		// find connected pixels
		//new ImagePlus("Labels Image", labelIm).show();
		for (int y = 0; y < h; y++) {

			offset = y * w;

			for (int x = 0; x < w; x++) {
				currentPixel = imagePixels.get(x + offset);
				curPixelValue = currentPixel.getIntHeight();
				
				if(curPixelValue > 0) { // pixel on the foreground
					count = 0;
					
					Pixel topLeftNeig   = currentPixel.getTopLeftNeighbour();
					Pixel topNeig       = currentPixel.getTopNeighbour();
					Pixel topRightNeig  = currentPixel.getTopRightNeighbour();
					Pixel leftNeig      = currentPixel.getLeftNeighbour();
					
					if(topLeftNeig != null)  neighboursLabels[0] = topLeftNeig.getLabel();
					else neighboursLabels[0] = Pixel.INIT;
					if(topNeig != null)      neighboursLabels[1] = topNeig.getLabel();
					else neighboursLabels[1] = Pixel.INIT;
					if(topRightNeig != null) neighboursLabels[2] = topRightNeig.getLabel();
					else neighboursLabels[2] = Pixel.INIT;
					if(leftNeig != null)     neighboursLabels[3] = leftNeig.getLabel();
					else neighboursLabels[3] = Pixel.INIT;
					
					for(int i=0; i<4; i++) {
						neigL = neighboursLabels[i]; 
					
						if(neigL != Pixel.INIT) {
							count++;
							curL = neigL;
							for(int j=0; j<i; j++) 
								if(neigL == neighboursLabels[j]) {
									count--;
									break;
								}
						}
					}	
					
					if(count == 0) {                                 // all neighbours are from background
						currentPixel.setLabel(label);
						if(connectedComps.size()-1 < label) { 
							connectedComp = new ArrayList<Pixel>();
							connectedComps.add(label, connectedComp);
						} else
							connectedComp = connectedComps.get(label);
						connectedComp.add(currentPixel);
						//labelIm.putPixelValue(x, y, (label+1)*10);
						label++;
					} /*else if(count == 1) {                          // only one neighbour is labeled
						currentPixel.setLabel(curL);
						labelIm.putPixelValue(x, y, (curL+1)*10);
					}*/ else {
						currentPixel.setLabel(curL);
						//labelIm.putPixelValue(x, y, (curL+1)*10);
						
						if(connectedComps.size()-1 < curL) {
						//if(connectedComp==null) {
							connectedComp = new ArrayList<Pixel>();
							connectedComps.add(label, connectedComp);
						} else
							connectedComp = connectedComps.get(curL);
						connectedComp.add(currentPixel);
						
						if(count > 1) {
							if(equivalenceMatrix == null)
								equivalenceMatrix = new Matrix(label, label, false);
							
							for(int i=0; i<4; i++) {
								neigL = neighboursLabels[i];
								
								if(neigL != Pixel.INIT)
									for(int j=0; j<4; j++) 
										if(neighboursLabels[j] != Pixel.INIT)
											//set equivalence Matrix 
											equivalenceMatrix.set(neigL, neighboursLabels[j], true);
							}
						}
					}
				}
			}
		}
		
		showConnectedComponents(connectedComps,w,h);
		
		//add reflexivity
		for(int i=0; i<equivalenceMatrix.getHeight(); i++)
			equivalenceMatrix.set(i, i, true);
		
		//add transitive closure
		for(int i=0; i<equivalenceMatrix.getHeight(); i++) {
			for(int j=0; j<equivalenceMatrix.getHeight(); j++) {
				if(equivalenceMatrix.get(j,i).equals(true)) 
					for(int k=0; k<equivalenceMatrix.getHeight(); k++)
						equivalenceMatrix.set(j, k, (Boolean) equivalenceMatrix.get(i, k) || (Boolean) equivalenceMatrix.get(j,k));
			}
		}
		
		//resolve equivalences
		int eqL = -1;
		/*for (int y = 0; y < h; y++) {

			offset = y * w;

			for (int x = 0; x < w; x++) {	
				eqL = -1;
				currentPixel = imagePixels.get(x + offset);
				curL = currentPixel.getLabel();
				for(int i=curL-1; i>=0; i--)
					if(equivalenceMatrix.get(curL, i).equals(true))
						eqL = i;
				if(eqL!=-1) {
					currentPixel.setLabel(eqL);
					labelIm.putPixelValue(x, y, (eqL+1)*10);
				}
			}
		}*/
		for(int k = 0; k < connectedComps.size(); k++) {
			eqL = -1;
			connectedComp = connectedComps.get(k); 
			if(connectedComp != null) {
				curL = connectedComp.get(0).getLabel();
				if(equivalenceMatrix.getHeight()-1 >= curL)
					for(int i = curL-1; i >= 0; i--)
						if(equivalenceMatrix.get(curL, i).equals(true))
							eqL = i;
			}
			if(eqL!=-1) {
				connectedComps.get(eqL).addAll(connectedComp);
				connectedComps.set(k,null);
			} 
		}
		
		// organize labels
		int k = 0;
		while( k < connectedComps.size() ) {
			connectedComp = connectedComps.get(k);
			if(connectedComp == null)
				connectedComps.remove(k);
			else {
				for(int i=0; i < connectedComp.size(); i++) {
					currentPixel = connectedComp.get(i);
					currentPixel.setLabel(k);
				}
				k++;
			}
		}
		
		showConnectedComponents(connectedComps,w,h);
		
		return connectedComps;
	}

	private static ArrayList<Pixel>			   imagePixels(ImageProcessor imageproc) {
		int w = imageproc.getWidth(), h = imageproc.getHeight();
		int offset, topOffset, bottomOffset;
		int pixelValue;
		ArrayList<Pixel> imagePixels = new ArrayList<Pixel>();
		
		// Create array de pixels
		for(int y=0; y<h; y++) {
			for(int x=0; x<w; x++) {
				pixelValue = imageproc.getPixel(x, y);
				Pixel pixel = new Pixel(x, y, (byte) pixelValue);
				imagePixels.add(pixel);
			}
		}
		
		// Add pixels neighbours
		for (int y = 0; y < h; y++) {

			offset = y * w;
			topOffset = offset + w;
			bottomOffset = offset - w;

			for (int x = 0; x < w; x++) {
				Pixel currentPixel = imagePixels.get(x + offset);

				if(y > 0) {
					if(x > 0)
						currentPixel.addNeighbour(imagePixels.get(x - 1 + bottomOffset));  // topLeft
					currentPixel.addNeighbour(imagePixels.get(x + bottomOffset));          // top
					if (x + 1 < w)
						currentPixel.addNeighbour(imagePixels.get(x + 1 + bottomOffset));  // topRight
				}
				
				if (x > 0) 
					currentPixel.addNeighbour(imagePixels.get(x - 1 + offset));            // left
				if (x + 1 < w) 
					currentPixel.addNeighbour(imagePixels.get(x + 1 + offset));            // right
				
				if (y + 1 < h) {
					if (x > 0) 
						currentPixel.addNeighbour(imagePixels.get(x - 1 + topOffset));     // bottomLeft
					currentPixel.addNeighbour(imagePixels.get(x + topOffset));             // bottom
					if (x + 1 < w) 
						currentPixel.addNeighbour(imagePixels.get(x + 1 + topOffset));     // bottomRight
				}
			
			}
		}

		return imagePixels;
	}

	public  static boolean 					   isAllBlack(ImageProcessor image) {
		int w = image.getWidth(), h = image.getHeight();
		
		for(int y=0; y<h; y++)
			for(int x=0; x<w; x++) {
				if(image.getPixel(x, y) != 0 )
					return false;
			}
		return true;
	}
	
	private static void 					   labelRBC(Pixel pixel, ArrayList<Pixel> labeledPixels, int label) {
		System.out.println(pixel.toString());
		pixel.setHeight((byte)0);
		pixel.setLabel(label);
		labeledPixels.add(pixel);
		Vector neighbours = pixel.getNeighbours();
		
		for(int i = 0; i < neighbours.size(); i++) {
			Pixel neighbour = (Pixel) neighbours.get(i);  
			if(neighbour.getIntHeight()==255)
				labelRBC(neighbour, labeledPixels, label);
		}
		return;
	}
	
	
	public  static int 						   maxX(ArrayList<Pixel> set) {
		int maxX = 0, x;
		Pixel curPixel;
		
		for(int i=0; i<set.size(); i++) {
			curPixel = set.get(i);
			x = curPixel.getX();
			if(x > maxX)
				maxX = x;
		}
		
		return maxX;
	}
	
	
	public  static int 						   maxY(ArrayList<Pixel> set) {
		int maxY = 0, y;
		Pixel curPixel;
		
		for(int i=0; i<set.size(); i++) {
			curPixel = set.get(i);
			y = curPixel.getY();
			if(y > maxY)
				maxY = y;
		}
		
		return maxY;
	}
	
	
	public  static int 						   minX(ArrayList<Pixel> set) {
		int minX = 10000, x;
		Pixel curPixel;
		
		for(int i=0; i<set.size(); i++) {
			curPixel = set.get(i);
			x = curPixel.getX();
			if(x < minX)
				minX = x;
		}
		
		return minX;
	}
	
	public  static int 						   minY(ArrayList<Pixel> set) {
		int minY = 10000, y;
		Pixel curPixel;
	
		for(int i=0; i<set.size(); i++) {
			curPixel = set.get(i);
			y = curPixel.getY();
			if(y < minY)
				minY = y;
			}
	
		return minY;
	}
	
	public  static double[] 			       normalizedHistogram(ImageProcessor image) {
		//ImagePlus imagePlus = new ImagePlus("", image);
		int[] hist;
		double[] hist_norm = new double[256];
		int N = image.getWidth()*image.getHeight();
		
		//hist = new HistogramWindow(imagePlus).getHistogram();
		hist = image.getHistogram();
		//Histogram Normalization
		/*for (int i = 0; i < hist.length; i++) {
			if(hist_max < hist[i]) {
				hist_max = hist[i]; 
	        }
	    }*/
		for (int i = 0; i < hist.length; i++) {
			hist_norm[i] = (float) hist[i]/N; 
	    }
		
		return hist_norm;
	}
		
	public  static double 					   pixelsDistance(Pixel p1, Pixel p2) {
		int x1 = p1.getX();
		int y1 = p1.getY();
		int x2 = p2.getX();
		int y2 = p2.getY();
		return Math.pow(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2), 0.5);
	}
	
	public  static Matrix 	     			   pixelsMatrix(ImageProcessor imageproc) {
		int w = imageproc.getWidth(), h = imageproc.getHeight();
		int offset, topOffset, bottomOffset;
		int pixelValue;
		//ArrayList<Pixel> imagePixels = new ArrayList<Pixel>();
		Matrix pixMatrix = new Matrix(w, h, null);
		Pixel currentPixel;
		
		// Create array de pixels
		for(int y=0; y<h; y++) {
			for(int x=0; x<w; x++) {
				pixelValue = imageproc.getPixel(x, y);
				currentPixel = new Pixel(x, y, (byte) pixelValue);
				pixMatrix.set(x, y, currentPixel);
			}
		}
		
		// Add pixels neighbours
		for (int y = 0; y < h; y++) {
			for (int x = 0; x < w; x++) {
				currentPixel = (Pixel) pixMatrix.get(x, y);

				if(y > 0) {
					if(x > 0)
						currentPixel.addNeighbour((Pixel) pixMatrix.get(x-1, y-1));    // topLeft
					currentPixel.addNeighbour((Pixel) pixMatrix.get(x, y-1));          // top
					if (x + 1 < w)
						currentPixel.addNeighbour((Pixel) pixMatrix.get(x+1, y-1));    // topRight
				}
				
				if (x > 0) 
					currentPixel.addNeighbour((Pixel) pixMatrix.get(x-1, y));          // left
				if (x + 1 < w) 
					currentPixel.addNeighbour((Pixel) pixMatrix.get(x+1, y));          // right
				
				if (y + 1 < h) {
					if (x > 0) 
						currentPixel.addNeighbour((Pixel) pixMatrix.get(x-1, y+1));    // bottomLeft
					currentPixel.addNeighbour((Pixel) pixMatrix.get(x, y+1));          // bottom
					if (x + 1 < w) 
						currentPixel.addNeighbour((Pixel) pixMatrix.get(x+1, y+1));    // bottomRight
				}
			
			}
		}

		return pixMatrix;
	}
	
	public  static ImageProcessor   		   putWhiteBorder(ImageProcessor image) {
		ImageProcessor image_out = new ByteProcessor(image.getWidth()+2, image.getHeight()+2);
		int[] whiteX = new int[image_out.getWidth()];
		int[] whiteY = new int[image_out.getHeight()];
		int[] pixels = new int[image.getWidth()];
		new ImagePlus("",image_out).show();
		
		for(int i=0; i<whiteX.length; i++) 
			whiteX[i] = 255;
		for(int i=0; i<whiteY.length; i++) 
			whiteY[i] = 255;
		
		image_out.putRow(0, 0, whiteX, whiteX.length);
		image_out.putRow(0, image_out.getHeight()-1, whiteX, whiteX.length);
		image_out.putColumn(0, 0, whiteY, whiteY.length);
		image_out.putColumn(image_out.getWidth()-1, 0, whiteY, whiteY.length);
		
		for(int i=1; i<image.getHeight(); i++) {
			image.getRow(0, i-1, pixels, pixels.length);
			image_out.putRow(1, i, pixels, pixels.length);
		}
				
		return image_out;
	}
	
	public  static ImageProcessor   		   removeBorder(ImageProcessor image) {
		ImageProcessor image_out;
		
		int value = image.getPixel(0, 0);
		int y, x;
		boolean stop = false;
		for(y = 0; y < image.getHeight(); y++) {
			for(x = 1; x < image.getWidth(); x++) {
				if(image.getPixel(x, y) != value) {
					stop = true;
					break; 
				}
			}
			if(stop)
				break;
		}
		
		if(y == 0)
			image_out = image;
		else {
			image.setRoi(y, y, image.getWidth()-2*y, image.getHeight()-2*y);
			image_out = image.crop();
		}
				
		return image_out.resize(image.getWidth(), image.getHeight());
	}
	
	private static void						   removeNeighbours(Pixel pixel, ImageProcessor image, Pixel reference, int diameter) {
		int x = pixel.getX();
		int y = pixel.getY();
		int width = image.getWidth();
		int height = image.getHeight();
		byte pixelHeight;
		Vector neighbours;
		//ArrayList<Pixel> pixelArray = new ArrayList<Pixel>();
		System.out.println(pixel.toString());
		//imagep.show();
		if (x + 1 < width) {
			pixelHeight = (byte) (image.getPixel(x+1, y));
			if((pixelHeight & 0xff)==255) {
				Pixel neighbour = new Pixel(x + 1, y, pixelHeight);
				if(pixelsDistance(neighbour, reference)<=diameter)
					pixel.addNeighbour(neighbour);
			}

			if (y - 1 >= 0) {
				pixelHeight = (byte) image.getPixel(x+1, y-1);
				if((pixelHeight & 0xff)==255) {
					Pixel neighbour = new Pixel(x + 1, y - 1, pixelHeight);
					if(pixelsDistance(neighbour, reference)<=diameter)
						pixel.addNeighbour(neighbour);
				}
			}

			if (y + 1 < height) {
				pixelHeight = (byte) image.getPixel(x+1, y+1);
				if((pixelHeight & 0xff)==255) {
					Pixel neighbour = new Pixel(x + 1, y + 1, pixelHeight);
					if(pixelsDistance(neighbour, reference)<=diameter)
						pixel.addNeighbour(neighbour);
				}
			}
		}

		if (x - 1 >= 0) {
			pixelHeight = (byte) image.getPixel(x-1, y);
			if((pixelHeight & 0xff)==255) {
				Pixel neighbour = new Pixel(x - 1, y, pixelHeight);
				if(pixelsDistance(neighbour, reference)<=diameter)
					pixel.addNeighbour(neighbour);
			}				

			if (y - 1 >= 0) {
				pixelHeight = (byte) image.getPixel(x-1, y-1);
				if((pixelHeight & 0xff)==255) {
					Pixel neighbour = new Pixel(x - 1, y - 1, pixelHeight);
					if(pixelsDistance(neighbour, reference)<=diameter)
						pixel.addNeighbour(neighbour);
				}
			}

			if (y + 1 < height) {
				pixelHeight = (byte) image.getPixel(x-1, y+1);
				if((pixelHeight & 0xff)==255) {
					Pixel neighbour = new Pixel(x - 1, y + 1, pixelHeight);
					if(pixelsDistance(neighbour, reference)<=diameter)
						pixel.addNeighbour(neighbour);
				}
			}
		}

		if (y - 1 >= 0) {
			pixelHeight = (byte) image.getPixel(x, y-1);
			if((pixelHeight & 0xff)==255) {
				Pixel neighbour = new Pixel(x, y - 1, pixelHeight);
				if(pixelsDistance(neighbour, reference)<=diameter)
					pixel.addNeighbour(neighbour);
			}
		}

		if (y + 1 < height) {
			pixelHeight = (byte) image.getPixel(x, y+1);
			if((pixelHeight & 0xff)==255) {
				Pixel neighbour = new Pixel(x, y + 1, pixelHeight);
				if(pixelsDistance(neighbour, reference)<=diameter)
					pixel.addNeighbour(neighbour);
			}
		}
		
		pixel.setHeight((byte) 0);
		image.putPixel(pixel.getX(), pixel.getY(), pixel.getHeight());
		//imagep.show();
		
		neighbours = pixel.getNeighbours();
		for(int i = 0; i < neighbours.size(); i++) {
			Pixel neighbour = (Pixel) neighbours.get(i);
			removeNeighbours(neighbour,image,reference,diameter);
			//neighbour.setHeight((byte) 0);
			//image.putPixel(neighbour.getX(), neighbour.getY(), neighbour.getIntHeight());
		}
		
		return;
	}
	
	public  static ImagePlus 				   runFFT(ImagePlus image) {
		ImagePlus fft = image;
		
		WindowManager.setTempCurrentImage(fft);
		IJ.run("FFT");
		
		fft = WindowManager.getCurrentImage();
		//fft.show();
		
		return fft;
	}
	
	public  static ImagePlus				   runInverseFFT(ImagePlus fftIm) {
		ImagePlus fftFilteredIm = fftIm;
		
		WindowManager.setTempCurrentImage(fftFilteredIm);
		IJ.run("Inverse FFT");
		
		fftFilteredIm = WindowManager.getCurrentImage();
		fftFilteredIm.show();
		
		return fftFilteredIm;
	}
	
	private static void 					   showConnectedComponents(ArrayList<ArrayList<Pixel>> connectedComps, int width, int height) {
		ArrayList<Pixel> connectedComp;
		Pixel currentPixel;
		int curL;
		ImageProcessor labelIm = new ByteProcessor(width, height);
		ImagePlus labelImPlus = new ImagePlus("Connected Components",labelIm);
		
		for( int k=0; k < connectedComps.size(); k++ ) {
			connectedComp = connectedComps.get(k);
			if(connectedComp != null) {
				for(int i=0; i < connectedComp.size(); i++) {
					currentPixel = connectedComp.get(i);
					curL = currentPixel.getLabel();
					labelIm.putPixelValue(currentPixel.getX(), currentPixel.getY(), (curL+1)*(256/connectedComps.size()));
				}
			}		
		}
		
		labelImPlus.show();
	}
	
	public  static ImageProcessor   		   switchBlackWhite(ImageProcessor image) {
		ImageProcessor switchedIm = image;
		
		for(int y = 0; y < image.getHeight(); y++) {
			for(int x = 0; x < image.getWidth(); x++) {
				if(image.getPixel(x, y) == 0)
					switchedIm.putPixelValue(x, y, 255);
				else if(image.getPixel(x, y) == 255)
					switchedIm.putPixelValue(x, y, 0);
				else {
					IJ.error("Error", "Image is not binary.");
					return null;
				}
			}
		}
		
		return switchedIm;
	}

	
}
