\section{Gerenciamento de memória do Linux}

Um gerenciador de memória é o mecanismo que prover meios para, dinamicamente, alocar porções de memória para os programas que solicitarem e liberá-la para reuso quando não forem mais necessárias. No Linux, o subsistema responsável pelo gerenciamento de memória é o \ac{LinuxMM}.

\subsection{Memória Virtual}

Os gerenciadores de memória utilizam o conceito de memória virtual para melhorar a eficiencia em sistemas multitarefas. A memória virtual permite que o gerenciador organize a memória independentemente da disposição física dos circuitos. As aplicações acessam a memória apenas através de endereços virtuais. Cada vez que é feita uma tentativa de acesso, o gerenciador traduz o endereço virtual em um endereço físico, que corresponde a localização do dado como armazenado no hardware.

Os \emph{chips} de memória são fabricados como uma matriz de células e são montados, tipicamente, divididos em bancos, que nada mais são que placas contendo alguns \ac{CI}s de memória e controladores, como na figura \ref{FIG:MEM_TOPOLOGIA}. Com a memória virtual a aplicação acessa a memória como um vetor de bytes unidimensional, como mostrado na figura \ref{FIG:MEM_VECTOR}.

\begin{figure}[!ht]
\centering
%\subfigure[\label{FIG:MEM_ARRAY}]{\includegraphics[width = 0.4 \linewidth]{figs/array.pdf}}
\subfigure[\label{FIG:MEM_TOPOLOGIA}]{\includegraphics[width = 0.4 \linewidth]{figs/topologia.pdf}}
\subfigure[\label{FIG:MEM_VECTOR}]{\includegraphics[width = 0.4 \linewidth]{figs/vector.pdf}}
\caption[Topologias da memória]{Topologia da memória como fisicamente montada (a) e como vista por uma aplicação (b).} \label{FIG:MEM_TOPOLOGY}
\end{figure}

Além disto, porçoes fragmentadas de memória física podem ser alocadas para um processo, mas o gerenciador virtualiza estes fragmentos em uma espaço continuo de endereçamento 

\begin{figure}[!ht]
\centering
\includegraphics[width = 0.5 \linewidth]{figs/mem_virtual.pdf}
\caption[Memória virtual]{Memória virtual (como alocada para um processo).} \label{FIG:MEM_VIRTUAL}
\end{figure}

A paginação é outro mecanismo dos gerenciadores e está geralmente associado à memória virtual. Ele faz com que o sistema guarde porções de dados da memória principal em uma memória secundária, recuperando-as posteriormente quando seu uso for solicitado. Desta forma, o sistema expande a memória virtual disponível para as aplicações. Geralmente se utiliza como memória secundária um espaço reservado no disco (HD, SSD, etc). Estes dispositivos são mais lentos que as \ac{RAM}s mas possuem maior disponibilidade de armazenamento e são mais baratos (valor por byte).

No Linux, o espaço reservado para paginação é chamado de \emph{swap} e pode estar presente ou não em um sistema, assim como pode ser habilitado, desabilitado ou redimensionado em tempo de execução.

Como o processo de salvar e recuperar as páginas do disco é lento, o Linux evita utilizar a área de \emph{swap} até que a disponibilidade de memória livre esteja baixa.

\subsection{Escassez de Memória}

A \ac{OOM} é um estado de um sistema computacional, geralmente indesejado, onde nenhuma memória adicional pode ser alocada para uso pelos programas ou pelo próprio sistema operacional.

No caso do Linux, para lidar com este tipo de situação é utilizada uma ferramenta parte do subsitema \ac{LinuxMM}, chamada de OOM \emph{Killer}, uma tarefa que sacrifica um ou mais processos para liberar memória para o systema \cite{OOMKILLER:2009}.

Programas que utilizam muita memória podem esgotar a memória do sistema, fazendo todo o sistema deixar de funcionar. Isto pode, por exemplo, levar a uma situação em que há tão pouca memória que o kernel não pode alocar memória para executar uma operção de liberação de memória. Então, OOM Killer é acionado e identifica os processos a serem sacrificados para beneficiar o resto do sistema.

O OOM Killer usa um esquema de pontuação para decidir qual ou quais processos sacrificar. Os pontos são dados pela função \emph{badness}, que utiliza uma fórmula relativamente simples, documentada no próprio código. As regras para gerar a pontuação são:

\begin{itemize}
  \item perder o mínimo de trabalho realizado;
  \item recuperar a maior quantidade de memória;
  \item não matar nada que tenha utilizado pouca memória;
  \item matar o mínimo de processos (de preferência apenas um);
  \item tentar matar o processo que o usuário espera que vá ser morto (menor surpresa).
\end{itemize}

\subsection{Linux Page Cache}

The Linux Page Cache ("Cached:" from meminfo ) is the largest single consumer of RAM on most systems. Any time you do a read() from a file on disk, that data is read into memory, and goes into the page cache(1.). After this read() completes, the kernel has the option to simply throw the page away since it is not being used. However, if you do a second read of the same area in a file, the data will be read directly out of memory and no trip to the disk will be taken. This is an incredible speedup and is the reason why Linux uses its page cache so extensively: it is betting that after you access a page on disk a single time, you will soon access it again.

The same is true for mmap()'d files ("Mapped:" in meminfo). The first time the mmap()'d area is accessed, the page will be brought in from the disk and mapped into memory. The kernel could choose to immediately discard that page after the instruction that touched the page has completed. However, the kernel makes the same bets that it did for simple read()s of the file. It keeps the page mapped into memory and bets that you will soon access it again. This behavior can manifest in confusing ways.

It might be assumed that mmap()'d memory is not "cached" because it is in active use and that "cached" means "completely unused right now". However, Linux does not define it that way. The Linux definition of "cached" is closer to "this is a copy of data from the disk that we have here to save you time". It implies nothing about how the page is actually being used. This is why we have both "Cached:" and "Mapped:" in meminfo. All "Mapped:" memory is "Cached:", but not all "Cached:" memory is "Mapped:".  